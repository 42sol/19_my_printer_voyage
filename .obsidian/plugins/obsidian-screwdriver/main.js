/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => ScrewDriverPlugin
});
var import_obsidian = __toModule(require("obsidian"));
function getFiles(app, path, ignoreList, filter) {
  return __async(this, null, function* () {
    const w = yield app.vault.adapter.list(path);
    let files = [
      ...w.files.filter((e) => !ignoreList.some((ee) => e.endsWith(ee))).filter((e) => !filter || filter.some((ee) => e.match(ee)))
    ];
    L1:
      for (const v of w.folders) {
        for (const ignore of ignoreList) {
          if (v.endsWith(ignore)) {
            continue L1;
          }
        }
        files = files.concat(yield getFiles(app, v, ignoreList, filter));
      }
    return files;
  });
}
function getDirectories(app, path, ignoreList) {
  return __async(this, null, function* () {
    const w = yield app.vault.adapter.list(path);
    let dirs = [];
    L1:
      for (const v of w.folders) {
        for (const ignore of ignoreList) {
          if (v.endsWith(ignore)) {
            continue L1;
          }
        }
        dirs = dirs.concat([v]);
        dirs = dirs.concat(yield getDirectories(app, v, ignoreList));
      }
    return dirs;
  });
}
function isPlainText(filename) {
  if (filename.endsWith(".md"))
    return true;
  if (filename.endsWith(".txt"))
    return true;
  if (filename.endsWith(".svg"))
    return true;
  if (filename.endsWith(".html"))
    return true;
  if (filename.endsWith(".csv"))
    return true;
  if (filename.endsWith(".css"))
    return true;
  if (filename.endsWith(".js"))
    return true;
  if (filename.endsWith(".json"))
    return true;
  if (filename.endsWith(".xml"))
    return true;
  if (filename.endsWith(".ts"))
    return true;
  if (filename.endsWith(".canvas"))
    return true;
  return false;
}
function ensureDirectory(app, fullpath) {
  return __async(this, null, function* () {
    const pathElements = fullpath.split("/");
    pathElements.pop();
    let c = "";
    for (const v of pathElements) {
      c += v;
      try {
        yield app.vault.createFolder(c);
      } catch (ex) {
        if (ex.message && ex.message == "Folder already exists.") {
        } else {
          new import_obsidian.Notice("Folder Create Error");
          console.log(ex);
        }
      }
      c += "/";
    }
  });
}
var ScrewDriverPlugin = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addCommand({
        id: "screwdriver-create-template",
        name: "Create dump template",
        editorCallback: (editor, view) => __async(this, null, function* () {
          const data = view.data;
          if (data.trim() != "") {
            new import_obsidian.Notice("Please clear the note once. This plugin write the template to this file");
            return;
          }
          const list = yield getDirectories(this.app, this.app.vault.configDir, ["node_modules", ".git"]);
          const targets = list.map((e) => `# target: ${e}`).join("\n");
          editor.setValue(`---
# --- Select a directory to dump. ---
${targets}

# --- Or, specify URLs to fetch.
urls:
# - https://gist.githubusercontent.com/vrtmrz/8b638347f56d1dad25414953bb95d7b6/raw/77f2965f79e9390b88dd17d5f23475b1f8b8085a/ninja-cursor-snippets.css

# --- Prefixes to ignore. ---
ignores:
- /node_modules
- /.git

# --- Regular expressions for filtering files
filters:
# - \\.js
---

`);
        })
      });
      this.addCommand({
        id: "screwdriver-dump",
        name: "Dump or fetch files",
        editorCallback: (editor, view) => __async(this, null, function* () {
          var _a, _b;
          const data = view.data;
          const bodyStartIndex = data.indexOf("\n---");
          if (!data.startsWith("---") || bodyStartIndex === -1) {
            new import_obsidian.Notice("Frontmatter was not found.");
          }
          const yaml = data.substring(3, bodyStartIndex);
          const yamlData = (0, import_obsidian.parseYaml)(yaml);
          let newData = "---" + yaml + "\n---\n\n";
          const target = (_a = yamlData.target) != null ? _a : "";
          const ignoresSrc = yamlData.ignores;
          const ignores = Array.isArray(ignoresSrc) ? ignoresSrc : (ignoresSrc + "").split(",");
          const filterSrc = yamlData.filters;
          const filters = !filterSrc ? null : filterSrc.map((e) => new RegExp(e));
          const urls = (_b = yamlData.urls) != null ? _b : "";
          if (target.trim() == "" && urls == "") {
            new import_obsidian.Notice("Target folders or urls are not specified.");
            return;
          }
          for (const url of urls) {
            try {
              let fileDat = "";
              let bin = false;
              const w = yield (0, import_obsidian.requestUrl)(url);
              const filename = new URL(url).pathname.split("/").last();
              const dt = w.arrayBuffer;
              try {
                const text = new TextDecoder("utf-8", { fatal: true }).decode(dt);
                fileDat = text;
                fileDat = fileDat.replace(/\\/g, "\\\\");
                fileDat = fileDat.replace(/`/g, "\\`");
              } catch (ex2) {
                fileDat = yield (0, import_obsidian.arrayBufferToBase64)(dt);
                bin = true;
              }
              newData += "\n";
              newData += `# ${url} 
`;
              newData += `- Fetched :${new Date().toLocaleString()} 
`;
              newData += "\n```" + filename + (bin ? ":bin" : "") + "\n";
              newData += fileDat + "";
              newData += "\n```";
            } catch (ex) {
              new import_obsidian.Notice(`Error on fetching ${url}
${ex}`);
            }
          }
          if (target != "") {
            const files = yield getFiles(this.app, target, ignores, filters);
            for (const file of files) {
              let fileDat = "";
              const stat = yield this.app.vault.adapter.stat(file);
              if (isPlainText(file)) {
                fileDat = yield this.app.vault.adapter.read(file);
                fileDat = fileDat.replace(/\\/g, "\\\\");
                fileDat = fileDat.replace(/`/g, "\\`");
              } else {
                const dtSrc = yield this.app.vault.adapter.readBinary(file);
                fileDat = yield (0, import_obsidian.arrayBufferToBase64)(dtSrc);
              }
              newData += "\n";
              newData += `# ${file} 
`;
              newData += `- Created :${new Date(stat.ctime).toLocaleString()} 
`;
              newData += `- Modified:${new Date(stat.mtime).toLocaleString()} 
`;
              newData += "\n```" + file + "\n";
              newData += fileDat + "";
              newData += "\n```";
            }
          }
          editor.setValue(newData);
        })
      });
      this.addCommand({
        id: "screwdriver-restore",
        name: "Restore files",
        editorCallback: (editor, view) => __async(this, null, function* () {
          const data = view.data;
          if (data.startsWith("---")) {
            const bodyStartIndex = data.indexOf("\n---");
            if (bodyStartIndex !== -1) {
              const preBlocks = data.substring(bodyStartIndex).matchAll(/^```([\s\S]*?)\n([\s\S]*?)^```/gm);
              for (const preBlock of preBlocks) {
                const [, filenameSrc, data2] = preBlock;
                const [filename, isBin] = `${filenameSrc}:`.split(":");
                console.dir(isBin);
                let saveData = data2;
                try {
                  if (isPlainText(filename) && isBin != "bin") {
                    saveData = saveData.replace(/\\`/g, "`");
                    saveData = saveData.replace(/\\\\/g, "\\");
                    saveData = saveData.substring(0, saveData.lastIndexOf("\n"));
                    yield ensureDirectory(this.app, filename);
                    yield this.app.vault.adapter.write(filename, saveData);
                  } else {
                    saveData = saveData.substring(0, saveData.lastIndexOf("\n"));
                    const saveDataArrayBuffer = (0, import_obsidian.base64ToArrayBuffer)(saveData);
                    yield ensureDirectory(this.app, filename);
                    yield this.app.vault.adapter.writeBinary(filename, saveDataArrayBuffer);
                  }
                  new import_obsidian.Notice(`File:${filename} has been wrote to your device.`);
                } catch (ex) {
                  new import_obsidian.Notice(`Failed to write ${filename}`);
                  console.log(ex);
                }
              }
              return;
            }
          }
          new import_obsidian.Notice("Frontmatter was not found.");
        })
      });
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
    });
  }
};
